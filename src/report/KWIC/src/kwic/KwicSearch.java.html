<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>KwicSearch.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">KWIC (May 31, 2015 7:57:00 PM)</a> &gt; <a href="../../index.html" class="el_group">KWIC</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">kwic</a> &gt; <span class="el_source">KwicSearch.java</span></div><h1>KwicSearch.java</h1><pre class="source lang-java linenums">package kwic;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.lang.Math;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This is the main class for performing a Key Word In Context (KWIC)
 * search on an ASCII file.  It contains the main data structures that 
 * hold the index generated from the text file and provides all the 
 * mechanisms to parse the file, generate the index, and lookup 
 * keywords from the index. 
 * 
 * 
 *
 */

public class KwicSearch {
	// Use helper classes to take values of constants
	private static final int MAX_KEY_COUNT = constantValues.MAX_KEY_COUNT;
	protected static final int DISPLAY_LINES_MAX = constantValues.DISPLAY_LINES_MAX;
	private static final int STRING_SIZE = constantValues.STRING_SIZE;
		
	// File name of the file to be indexed (Default to abc.txt)
<span class="pc" id="L32">	private String mFileName = &quot;abc.txt&quot;;</span>
	
	// Status flag for index generation process
<span class="pc" id="L35">	private boolean mIndexDone = false;</span>
	
	// Worker Thread to generate keyword index
	private Thread mIndexWorkThread;
	
	
	/* Main keyword index
	 * This is the main data structure for holding the keyword index
	 */

<span class="pc" id="L45">	private Map&lt;String, variableValues&gt; mKeywordMap = new HashMap&lt;String, variableValues&gt;();</span>
	/* Dead word list
	 * This is a list of words that have already been seen too many times
	 * It may be quicker to check this list before attempting to add new 
	 * words to the main keyword map
	 */
<span class="pc" id="L51">	private Set&lt;String&gt; mDeadWordsList = new HashSet&lt;String&gt;();</span>
	
	// Define the index worker runnable
<span class="fc" id="L54">	private class IndexWorker implements Runnable {</span>

		// Define run method
		@Override
		public void run() {
			// Execute code to build the index for the specified text file
			try{
<span class="fc" id="L61">				buildIndex();</span>
<span class="fc" id="L62">			}</span>
<span class="nc" id="L63">			catch (IOException e){</span>
<span class="nc" id="L64">				e.printStackTrace();</span>
			}
			
<span class="fc" id="L67">		}</span>
	}

	
	// Basic Constructor
	/*
	 *  Note: the default file name is &quot;OliverTwist.txt&quot;, which
	 *  may not exist or be findable from the context where this
	 *  application is run.  This constructor is not used in the 
	 *  original implementation of the KWIC application 
	 */
<span class="nc" id="L78">	public KwicSearch(){</span>
		// Create worker thread
<span class="nc" id="L80">		this.mIndexWorkThread = new Thread(new IndexWorker());</span>
<span class="nc" id="L81">	}</span>
		
	// Constructor that sets file name to search
<span class="fc" id="L84">	public KwicSearch(String fileName){</span>
		// Set file name to search
<span class="fc" id="L86">		this.mFileName = fileName;</span>
		// Create worker thread
<span class="fc" id="L88">		this.mIndexWorkThread = new Thread(new IndexWorker());</span>
<span class="fc" id="L89">	}</span>
	
	// Method to build the index for the named text file
	private void buildIndex() throws IOException {
		// Define file input stream
<span class="fc" id="L94">		BufferedReader inputStream = null;</span>
		
		/*
		 *  Define Strings to hold lines of text
		 *  In order to allow context to wrap over line breaks we need
		 *  to always have &quot;prev&quot; and &quot;next&quot; line data available
		 */
<span class="fc" id="L101">		String prevLine = null, currLine = null, nextLine = null;</span>
		String lineWords, allLines;
		// Define variables for length of line buffers
		int prevLen, currLen, nextLen;
		
		
		// Define and initialize line number counter
		// (count one behind because we need to buffer the input)
<span class="fc" id="L109">		int lineNum = 0; </span>
		
		// Define loop done flag for main loop over lines in file
		// Default to true so that if the first readline fails we don't process anything
<span class="fc" id="L113">		boolean loopDone = true;</span>
		
		// Initialize safety counter for while loop
		// TODO: Consider getting rid of this, it may be sloppy design
<span class="fc" id="L117">		int safeCntr = 0;</span>

		// --- Define variables used in context string creation ---

<span class="fc" id="L121">		Pattern pattern = Pattern.compile(&quot;[a-zA-Z]+'?[a-zA-Z]&quot;);</span>
		Matcher matcher;
		// Holders for start and stop index from Regex matches
		int startInd, endInd;
		// Holder for matched word from Regex
		String parsedWord;
		
		// Holder for length of full buffer
		int fullLen;
		// Holders for updated start and end indices of keyword within full buffer
		int fullStartInd, fullEndInd;
		
		// Initialize sizes of left-side and right-side padding strings
<span class="fc" id="L134">		int leftPadSize = 0, rightPadSize = 0;</span>
		// Initialize left-side and right-side padding strings
<span class="fc" id="L136">		String leftPad = &quot;&quot;, rightPad = &quot;&quot;;</span>
		// Declare left and right context strings
		String leftContext, rightContext, fullContext;
		
		// Define String to mark line breaks (new line) in context window
<span class="fc" id="L141">		String lineBreakStr = &quot; &quot;;</span>
		// ---------- End context string create variables ---------
		
		// Define flag to check if last word of prev line wrapped to curr line
		/*
		 *  Note: this will probably be handy if I add functionality to handle
		 *  hyphenated word continuations on the next line 
		 */
<span class="fc" id="L149">		boolean wrapWord = false;</span>
		
		// Define a KeywordContainer to use
<span class="fc" id="L152">		variableValues keyContainer = null;</span>
		
		/*
		 * Read in one line at a time from text file and generate keyword index
		 */
		try{
			// Create file input streams
<span class="fc" id="L159">			inputStream 	= new BufferedReader(new FileReader(mFileName));</span>
			
			// Read in first line and initialize buffers 
<span class="fc" id="L162">			lineWords = cleanupFirstLine(inputStream.readLine());</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">			if (lineWords != null){</span>
<span class="fc" id="L164">				nextLine = lineWords;</span>
<span class="fc" id="L165">				loopDone = false;</span>
			}
			
			// Loop over lines of text in file
<span class="pc bpc" id="L169" title="1 of 4 branches missed.">			while( !loopDone &amp;&amp; safeCntr &lt; constantValues.MAX_TEXT_LINES){</span>
				// Increment safety counter
				// TODO: consider getting rid of this, it may be sloppy
<span class="fc" id="L172">				safeCntr++;</span>
				
				// Get next line from file
<span class="fc" id="L175">				lineWords = inputStream.readLine();</span>
				
				// Check if this is the last pass
<span class="fc bfc" id="L178" title="All 2 branches covered.">				if (lineWords == null){</span>
<span class="fc" id="L179">					loopDone = true;</span>
				} 
				
				// Increment line counter (count one behind because we need to buffer the input)
<span class="fc" id="L183">				lineNum++;</span>
				
				// Update line buffers for this round
<span class="fc" id="L186">				prevLine = currLine;</span>
<span class="fc" id="L187">				currLine = nextLine;</span>
<span class="fc" id="L188">				nextLine = lineWords;</span>
				
				// Update line buffer metrics
<span class="fc bfc" id="L191" title="All 2 branches covered.">				prevLen = (prevLine == null) ? 0 : prevLine.length();</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">				currLen = (currLine == null) ? 0 : currLine.length();</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">				nextLen = (nextLine == null) ? 0 : nextLine.length();</span>
								
				
				//--- Build full buffer ---
<span class="fc bfc" id="L197" title="All 2 branches covered.">				if (prevLen &gt; 0){</span>
<span class="fc" id="L198">					allLines = prevLine+lineBreakStr+currLine;</span>
<span class="fc" id="L199">					prevLen+=lineBreakStr.length();</span>
<span class="fc" id="L200">				} else {</span>
<span class="fc" id="L201">					allLines = currLine;</span>
				}
<span class="fc bfc" id="L203" title="All 2 branches covered.">				if (nextLen &gt; 0){</span>
<span class="fc" id="L204">					allLines = allLines+lineBreakStr+nextLine;</span>
				}
				// Compute length of full buffer
<span class="fc" id="L207">				fullLen = allLines.length();</span>
				
				
				// Create pattern matcher for current line
<span class="fc" id="L211">				matcher = pattern.matcher(currLine);</span>
				
				// Loop over matching patterns in current line
<span class="fc bfc" id="L214" title="All 2 branches covered.">				while (matcher.find()){</span>
					// Grab keyword
<span class="fc" id="L216">					parsedWord 	= matcher.group().toLowerCase();</span>
					// Grab start and end indices of keyword
<span class="fc" id="L218">					startInd 	= matcher.start();</span>
<span class="fc" id="L219">					endInd 		= matcher.end();</span>
										
					
					/*
					 * Check each word in this line, add to Map and increment word count
					 * 
					 * This implementation uses a &quot;dead list&quot; and a main index.  
					 * The idea is that there may be an implementation of a list of &quot;dead&quot;
					 * words that can be checked more quickly than checking for
					 * the number of instances of a queried keyword in the main index.  
					 * Additionally, if a word is known to be &quot;dead&quot;, there is no need to
					 * perform the processing to create the context data.
					 * For now, the dead list is implemented as a Java HashSet, which
					 * does not allow duplicate values.  If search times are slow, it
					 * may be a good idea to switch to a red-black tree or prioritized
					 * set so that commonly checked words can be found quickly. 
					 */
					// Check dead list
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">					if (mDeadWordsList.contains(parsedWord)){</span>
						// This word is already on the dead list
						
						// TODO: Do stuff to get more benefit from deadlist
						
					} else {
						// This word is not dead yet
					
						//-------- Create context Data --------
						// Compute new keyword start and stop indices for full buffer
<span class="fc" id="L247">						fullStartInd 	= startInd + prevLen;</span>
<span class="fc" id="L248">						fullEndInd 		= endInd + prevLen;</span>
						
						/*
						 * Create any necessary extra white space characters
						 * 
						 * If there are not enough extra characters before the 
						 * keyword in the full buffer, fill the rest of the 
						 * left-side context buffer with characters.  Likewise 
						 * fill up the right-side context buffer with extra
						 * white space characters if necessary 
						 */
<span class="fc" id="L259">						leftPadSize = STRING_SIZE-fullStartInd;</span>
						// Right pad size is N - (len - endInd)
<span class="fc" id="L261">						rightPadSize = STRING_SIZE - fullLen + fullEndInd;</span>
						
						//--- Generate Padding and Context Data ---
						//-- Left side context 
<span class="fc bfc" id="L265" title="All 2 branches covered.">						if ( leftPadSize &gt; 0){</span>
<span class="fc" id="L266">							leftPad = String.format(&quot;%1$&quot;+leftPadSize+&quot;s&quot;,&quot;&quot;);</span>
<span class="fc" id="L267">							leftContext = leftPad+allLines.substring(0, fullStartInd);</span>
<span class="fc" id="L268">						} else {</span>
<span class="fc" id="L269">							leftContext = allLines.substring(fullStartInd - STRING_SIZE,fullStartInd);</span>
						}
						//-- Right side context
<span class="fc bfc" id="L272" title="All 2 branches covered.">						if (rightPadSize &gt; 0){</span>
<span class="fc" id="L273">							rightPad = String.format(&quot;%1$&quot;+rightPadSize+&quot;s&quot;,&quot;&quot;);</span>
<span class="fc" id="L274">							rightContext = allLines.substring(fullEndInd) + rightPad;</span>
<span class="fc" id="L275">						} else {</span>
<span class="fc" id="L276">							rightContext = allLines.substring(fullEndInd,fullEndInd + STRING_SIZE);</span>
						}
						
						// Construct full context string
<span class="fc" id="L280">						fullContext = leftContext+allLines.substring(fullStartInd, fullEndInd)+rightContext;</span>
						//-------- End Create context Data --------				
						
						
												
						// Check if this word is already in the index
<span class="fc" id="L286">						keyContainer = mKeywordMap.get(parsedWord);</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">						if (keyContainer == null){</span>
							// Add this keyword to the index
							/*
							 *  Note: building index on all lower case keywords, this will
							 *  have implications on expected results with regard to
							 *  case-sensitivity 
							 */
<span class="fc" id="L294">							mKeywordMap.put(parsedWord, new variableValues(1,new KeywordData(lineNum,fullContext)));</span>
<span class="fc" id="L295">						} else {</span>
							// Add another instance of this keyword to the index
<span class="fc" id="L297">							keyContainer.incrementWordCount();</span>
<span class="fc" id="L298">							keyContainer.getDetailList().add(new KeywordData(lineNum,fullContext));</span>
							
							// Check if we need to kill this keyword now
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">							if (keyContainer.getWordCount()&gt;=MAX_KEY_COUNT){</span>
								// Add this word to the dead list so we don't keep adding to the index
<span class="nc" id="L303">								mDeadWordsList.add(parsedWord);</span>
							}
						} // End of adding new instance to index	
					} // End of checking dead list
					
				} // End of while loop over matching regex patterns		
				
			} // End of while loop over file
			// Check if we only broke out because of loop limit
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">			if (!loopDone){</span>
<span class="nc" id="L313">				System.out.format(&quot;%nThe whole file may not have been indexed.&quot;+</span>
									&quot;%nConsider increasing the MAX_TEXT_LINES variable.%n&quot;);
			}
			
<span class="nc" id="L317">		} // End of try block (mostly for inputStream FileReader)</span>
		/*
		 * TODO: Consider adding exception handling for some other
		 * activities going on in here, such as the regex processing
		 * and potential null pointer issues in the dead list and
		 * main index
		 */
<span class="nc" id="L324">		finally {</span>
			// Set index finished flag to true
<span class="pc" id="L326">			mIndexDone = true;</span>
			
<span class="pc bpc" id="L328" title="3 of 4 branches missed.">			if(inputStream != null){</span>
<span class="pc" id="L329">				inputStream.close();</span>
			}			
<span class="nc" id="L331">		}</span>
<span class="fc" id="L332">	}</span>
	
	/*
	 * Method to implement query processing
	 */
	protected void processQueryKeyword(String keyword){
		int lineNum;
<span class="fc" id="L339">		int lineNumStrSize = 10;</span>
		String contextStr;
		String lineNumStr;
		String padding;
		
<span class="fc" id="L344">		variableValues keyContainer = mKeywordMap.get(keyword.toLowerCase());</span>
		KeywordData wordData;
		
<span class="fc bfc" id="L347" title="All 2 branches covered.">		if (keyContainer == null){</span>
			// Keyword was not found in index
<span class="fc" id="L349">			System.out.format(&quot;%nSorry, the keyword \&quot;&quot;+keyword+&quot;\&quot; was not found in the index&quot;);</span>
<span class="fc" id="L350">		} else {</span>
			//System.out.format(&quot;%nThe keyword \&quot;&quot;+keyword+&quot;\&quot;  was found in the following contexts:%n&quot;);
<span class="fc" id="L352">			System.out.println();</span>
<span class="fc" id="L353">			System.out.format(keyword);</span>
			
			// Loop over all found indices of the keyword
<span class="fc bfc" id="L356" title="All 2 branches covered.">			for (int keywordInd = 0; keywordInd &lt; Math.min(keyContainer.getWordCount(),DISPLAY_LINES_MAX); keywordInd++){</span>
				// Get the data for this instance of the keyword
<span class="fc" id="L358">				wordData = keyContainer.getDetailList().get(keywordInd);</span>
				
				//--- Get the line number and the context string
<span class="fc" id="L361">				lineNum = wordData.getLineNubmer();</span>
<span class="fc" id="L362">				contextStr = wordData.getContextStr();</span>
				
				//--- Print the summary for this instance
				// Format line number string
<span class="fc" id="L366">				lineNumStr = Integer.toString(lineNum);</span>
<span class="fc" id="L367">				padding = String.format(&quot;%1$&quot;+(lineNumStrSize-lineNumStr.length())+&quot;s&quot;,&quot;&quot;);</span>
<span class="fc" id="L368">				lineNumStr = lineNumStr+padding;</span>
				// Print summary
<span class="fc" id="L370">				System.out.format(&quot;%n%s:%s&quot;,lineNumStr,contextStr);</span>
			}
		}
<span class="fc" id="L373">	}</span>
	
	// Method to start the Index worker thread
	protected void startIndexWorker(){
		// Start the indexWorkerThread Thread
<span class="fc" id="L378">		mIndexWorkThread.start();</span>
<span class="fc" id="L379">	}</span>
	
	// Getter for IndexDone flag
	protected boolean isIndexDone(){
<span class="fc" id="L383">		return mIndexDone;</span>
	}
	
	// Setter for IndexDone flag
	// This should not be needed, but it is available just in case
	protected void setIndexDone(boolean isDone){
<span class="nc" id="L389">		mIndexDone = isDone;</span>
<span class="nc" id="L390">	}</span>
	
	// Method to ensure some data quality of the first line in the file
	protected String cleanupFirstLine(String inStr){
<span class="fc" id="L394">		String cleanStr = null;</span>
		// Define known utf Byte Order Markings (BOM) code point
<span class="fc" id="L396">		int bomCodePoint = 65279;</span>
		// Grab the first character in the 
<span class="fc" id="L398">		int firstCode = inStr.codePointAt(0);</span>
		
		
		// Check if first character is BOM and remove it from string if so
		/*
		 * If text files are properly saved as ASCII, these characters should not be present,
		 * but let's check just to be safe.
		 */
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">		if (firstCode == bomCodePoint){</span>
<span class="nc" id="L407">			cleanStr = inStr.substring(1);</span>
<span class="nc" id="L408">		} else {</span>
<span class="fc" id="L409">			cleanStr = inStr;</span>
		}
		
<span class="fc" id="L412">		return cleanStr;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>KWIC (May 31, 2015 7:57:00 PM)</div></body></html>